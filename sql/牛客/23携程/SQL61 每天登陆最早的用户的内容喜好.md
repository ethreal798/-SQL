## ***\*SQL61 每天登陆最早的用户的内容喜好\****

### 做什么

问题：请查询每天登陆最早的用户的内容喜好？

注：如果当天出现多个用户同时最早登录，那么这些用户均需要输出

输出日期、用户id、用户内容喜好，结果按照日期升序排序

示例输出如下：

| log_day    | user_id | hobby |
| ---------- | ------- | ----- |
| 2022-02-06 | 101     | 健身  |
| 2022-02-06 | 102     | 影视  |
| 2022-02-07 | 102     | 影视  |
| 2022-02-08 | 102     | 影视  |
| 2022-02-09 | 103     | 美妆  |



解释：2022年2月6日用户101和102均在7:24登录，故在当天最早登录的用户是101和102，他们内容喜好标签分别是健身、影视。

其他结果同理



- 每天的登录最早的用户
- 注意如果有并列最早，需要都输出
- 升序排序 

### 怎么做

- 示例输出   log_day是 YYYY-MM-DD 所以我们可以想到使用date_format()函数 
- 因为用户被筛选了 所以我们可以考虑用子查询对login_tb进行用户的筛选或者构建可以筛选用户的字段
- 其次每天的登录最早 以及并列情况  我们很容易想到窗口函数计算排名  又因为并列所以使用rank()
- 剩下就是表连接的内容

### 代码展示

```
select 
    l.log_day,
    l.user_id,
    u.hobby
from(
    select
        date_format(log_time,'%Y-%m-%d') log_day,
        user_id,
        rank() over(Partition by date_format(log_time,'%Y-%m-%d') order by log_time) pm
    from login_tb
)l 
join 
    user_action_tb u
on l.user_id = u.user_id and l.pm=1
```

### 我的错误：

我在子查询中使用where pm=1进行筛选 ，但是窗口函数的别名pm是在窗口函数结束后才得到。所以where pm此时是拿不到pm这个字段的

- `RANK()` 是窗口函数，必须等 SQL 的 `SELECT` 阶段执行后才生成别名 `pm`。
- 所以不能在同一层的 `WHERE` 子句中使用别名 `pm`，应在外层使用。